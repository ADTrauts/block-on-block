---
description: Comprehensive coding standards and patterns for Vssyl to prevent recurring errors
globs: 
alwaysApply: true
---

# Vssyl Coding Standards & Patterns

## üöÄ Google Cloud Production Infrastructure

### Production URLs (DO NOT HARDCODE LOCALHOST)
```typescript
// ‚úÖ ALWAYS use environment variables with production fallback
const API_BASE_URL = process.env.NEXT_PUBLIC_API_BASE_URL || 
                     process.env.NEXT_PUBLIC_API_URL || 
                     'https://vssyl-server-235369681725.us-central1.run.app';

// ‚ùå NEVER hardcode localhost in production code
const API_URL = 'http://localhost:5000'; // WRONG!
```

**Critical URLs:**
- **Frontend**: `https://vssyl.com` (production)
- **Backend**: `https://vssyl-server-235369681725.us-central1.run.app`
- **WebSocket**: `wss://vssyl-server-235369681725.us-central1.run.app/socket.io/`

### Cloud Build Configuration
- **Machine Type**: `E2_HIGHCPU_8` (required for fast builds)
- **Build Time**: ~7-10 minutes expected
- **Region**: `us-central1`

### Docker Configuration
- **Multi-stage builds**: Required for production
- **Prisma generation**: Must run BEFORE TypeScript compilation
- **Node version**: 20.x (specified in engines)

---

## üîß Environment Variable Standards

### Hierarchy (ALWAYS follow this order)
```typescript
// WebSocket connections
const WS_URL = process.env.NEXT_PUBLIC_WS_URL || 
               process.env.NEXT_PUBLIC_API_BASE_URL || 
               process.env.NEXT_PUBLIC_API_URL || 
               'https://vssyl-server-235369681725.us-central1.run.app';

// API connections
const API_BASE_URL = process.env.NEXT_PUBLIC_API_BASE_URL || 
                     process.env.NEXT_PUBLIC_API_URL || 
                     'https://vssyl-server-235369681725.us-central1.run.app';
```

### Required Environment Variables

**Frontend (.env.local / production):**
```bash
NEXTAUTH_URL=https://vssyl.com
NEXTAUTH_SECRET=<32+ char secret>
NEXT_PUBLIC_API_BASE_URL=https://vssyl-server-235369681725.us-central1.run.app
NEXT_PUBLIC_APP_URL=https://vssyl.com
NEXT_PUBLIC_WS_URL=wss://vssyl-server-235369681725.us-central1.run.app
```

**Backend (.env / production):**
```bash
NODE_ENV=production
DATABASE_URL=postgresql://user:pass@172.30.0.15:5432/vssyl_production?connection_limit=20&pool_timeout=20
JWT_SECRET=<generated with openssl rand -base64 32>
JWT_REFRESH_SECRET=<generated with openssl rand -base64 32>
FRONTEND_URL=https://vssyl.com
STORAGE_PROVIDER=gcs
GOOGLE_CLOUD_PROJECT_ID=vssyl-472202
GOOGLE_CLOUD_STORAGE_BUCKET=vssyl-storage-472202
```

### Rules
1. **PRIMARY**: Always use `NEXT_PUBLIC_API_BASE_URL`
2. **FALLBACK**: Always provide production URL as final fallback
3. **NEVER**: Hardcode localhost URLs in code that might run in production
4. **ALWAYS**: Use environment-specific `.env` files

---

## üîí Authentication Patterns

### NextAuth.js (Frontend)
```typescript
// ‚úÖ CORRECT: Get token in API routes
import { getToken } from 'next-auth/jwt';

const token = await getToken({ req, secret: process.env.NEXTAUTH_SECRET });
const accessToken = (token as any)?.accessToken;
```

### JWT (Backend)
```typescript
// ‚úÖ CORRECT: Always check user existence
const user = req.user;
if (!user) {
  return res.status(401).json({ error: 'User not authenticated' });
}

// Now safe to use user.id, user.email, etc.
```

### Security Rules
1. **JWT_SECRET**: Must be 32+ characters (use `openssl rand -base64 32`)
2. **Always validate**: Check `req.user` exists before accessing properties
3. **Never log secrets**: Don't console.log tokens or passwords
4. **Bcrypt passwords**: Always use bcrypt with salt rounds >= 10

---

## üõ£Ô∏è API Routing Patterns

### Backend Controller/Route Naming Convention

**CRITICAL**: Route handler names MUST match exported controller function names exactly.

```typescript
// ‚úÖ CORRECT: Matching names

// routes/module.ts
import * as moduleController from '../controllers/moduleController.js';  // Note .js extension
router.get('/admin/items', checkAdmin, moduleController.getItems);
router.get('/admin/items/:id', checkAdmin, moduleController.getItemById);

// controllers/moduleController.ts
export async function getItems(req: Request, res: Response): Promise<void> { }
export async function getItemById(req: Request, res: Response): Promise<void> { }

// ‚ùå WRONG: Name mismatch
// routes/module.ts calls moduleController.getItems
// controllers/moduleController.ts exports listItems  // MISMATCH!
```

**Rules:**
1. **Use `.js` extension**: Import controllers with `.js` (TypeScript resolution)
2. **Match names exactly**: Route calls must match exported function names
3. **Export all stubs**: Even unimplemented functions must be exported
4. **Standard naming**: Use `get[Items]`, `get[Item]ById`, `create[Item]`, `update[Item]`, `delete[Item]`

---

### Next.js API Proxy (MANDATORY PATTERN)
```typescript
// web/src/app/api/[...slug]/route.ts
const backendUrl = process.env.BACKEND_URL || 
                  process.env.NEXT_PUBLIC_API_BASE_URL || 
                  'https://vssyl-server-235369681725.us-central1.run.app';

// Forward ALL /api/* requests to backend
const url = `${backendUrl}${pathname}${search}`;
```

### API Client Functions
```typescript
// ‚úÖ CORRECT: Use relative paths (proxy adds /api prefix)
const endpoint = `/conversations`;
return apiCall(endpoint, { method: 'GET' }, token);

// ‚ùå WRONG: Don't duplicate /api prefix
const endpoint = `/api/chat/conversations`; // This creates /api/chat/api/chat/conversations!
```

### Critical Rules
1. **NO DOUBLE PREFIXES**: API client functions use relative paths
2. **PROXY HANDLES AUTH**: API proxy adds authentication headers automatically
3. **USE NEXT.JS PROXY**: Don't bypass the `/api/[...slug]/route.ts` proxy
4. **CONSISTENT PATTERN**: All API routes follow same structure

### Common Errors to Avoid
```typescript
// ‚ùå WRONG: Double /api paths
'/api/chat/conversations' when apiCall already adds '/api/chat'

// ‚ùå WRONG: Bypassing proxy
fetch('https://vssyl-server-235369681725.us-central1.run.app/api/...')

// ‚úÖ CORRECT: Let proxy handle it
fetch('/api/conversations')
```

---

## üîå API Client Implementation Pattern

### Frontend API Client Structure

**CRITICAL**: API client files do NOT import from `apiClient` - they use native `fetch` with helper functions.

```typescript
// ‚úÖ CORRECT: API client structure (web/src/api/[module].ts)

// Helper function for auth headers
function authHeaders(token: string, headers: Record<string, string> = {}) {
  return { ...headers, Authorization: `Bearer ${token}` };
}

// API functions use native fetch
export async function getData(businessId: string, token?: string): Promise<Data[]> {
  if (!token) throw new Error('Authentication required');
  const res = await fetch(`/api/module/data?businessId=${businessId}`, {
    headers: authHeaders(token),
  });
  if (!res.ok) throw new Error('Failed to fetch data');
  const data = await res.json();
  return data.items || data;
}
```

**Rules:**
1. **NO apiClient import** - Use native `fetch` directly
2. **Include authHeaders helper** - Copy from existing API files (drive.ts, chat.ts)
3. **Always check token** - Throw error if missing
4. **Consistent error handling** - Check `res.ok` and throw descriptive errors
5. **Use /api/ prefix** - All calls go through Next.js proxy

---

## üé® Shared Component Import Pattern

### Correct Import Path

```typescript
// ‚úÖ CORRECT: Import from 'shared/components'
import { Button, Card, Spinner } from 'shared/components';

// ‚ùå WRONG: These paths don't exist
import { Button } from '@/components/ui/button';
import { Button } from '../../shared/src/components/Button';
```

### Available Components & Props

**Button variants:**
```typescript
variant?: 'primary' | 'secondary' | 'ghost'  // NOT 'outline' or 'default'
size?: 'sm' | 'md' | 'lg'
```

**Card component:**
```typescript
// Simple Card - no subcomponents
<Card className="optional-classes">
  <div className="p-4">
    <h3 className="text-lg font-semibold">Title</h3>
    <p>Content</p>
  </div>
</Card>

// ‚ùå WRONG: These don't exist
<CardHeader>, <CardTitle>, <CardContent>
```

**Other components:**
- `Alert`, `Badge`, `Spinner`, `Tabs`, `Switch`, `Modal`, `Input`, `Textarea`
- Check `shared/src/components/` for full list

---

## üé® UI/Design Standards

### Text Color Contrast (CRITICAL - READABILITY)

**NEVER use light text colors on light backgrounds.** This causes severe readability issues and makes text unreadable unless highlighted.

```typescript
// ‚ùå WRONG: Light text on light background (unreadable)
<p className="text-gray-500">Label text</p>  // Too light on white/light gray
<p className="text-gray-400">Description</p>  // Even worse
<span className="text-gray-300">Metadata</span>  // Nearly invisible

// ‚úÖ CORRECT: Dark text on light background (readable)
<p className="text-gray-700">Label text</p>  // Dark enough to read
<p className="text-gray-600">Description</p>  // Still readable
<span className="text-gray-900">Metadata</span>  // Maximum contrast

// ‚úÖ CORRECT: Light text on dark background (readable)
<div className="bg-gray-900">
  <p className="text-gray-300">Light text on dark</p>  // OK on dark backgrounds
  <p className="text-white">Maximum contrast</p>
</div>
```

**Minimum Text Color Standards:**
- **Light backgrounds (white, gray-50, gray-100)**: Use `text-gray-700` or darker
  - Labels: `text-gray-700` or `text-gray-900`
  - Descriptions: `text-gray-600` or `text-gray-700`
  - Secondary text: `text-gray-600` minimum
- **Dark backgrounds (gray-800, gray-900)**: Use `text-gray-300` or lighter
  - Primary text: `text-white` or `text-gray-100`
  - Secondary text: `text-gray-300` or `text-gray-400`

**Forbidden Combinations:**
- ‚ùå `text-gray-500` on white/light backgrounds
- ‚ùå `text-gray-400` on white/light backgrounds  
- ‚ùå `text-gray-300` on white/light backgrounds
- ‚ùå Any text color lighter than `text-gray-600` on backgrounds lighter than `bg-gray-200`

**Acceptable Light Text Colors (ONLY on dark backgrounds):**
- ‚úÖ `text-gray-300` on `bg-gray-800` or darker
- ‚úÖ `text-gray-400` on `bg-gray-900`
- ‚úÖ `text-white` on any dark background

**Rules:**
1. **Always check contrast**: Text must be clearly readable without highlighting
2. **Test on actual backgrounds**: Don't assume - verify text is readable
3. **Use darker shades**: When in doubt, use `text-gray-700` or `text-gray-900` on light backgrounds
4. **Consider accessibility**: WCAG AA requires 4.5:1 contrast ratio for normal text
5. **Inactive states**: Even inactive tabs/buttons should use `text-gray-600` minimum (not `text-gray-500`)

**Common Patterns:**
```typescript
// ‚úÖ CORRECT: Metric labels
<p className="text-xs text-gray-700 mb-1">Total Users</p>
<p className="text-lg font-semibold text-gray-900">1,234</p>

// ‚úÖ CORRECT: Timestamps and metadata
<span className="text-xs text-gray-700">2 min ago</span>
<span className="text-sm text-gray-600">Last updated</span>

// ‚úÖ CORRECT: Empty states
<div className="text-center py-8 text-gray-700">
  <p>No data available</p>
</div>

// ‚ùå WRONG: All of these are too light
<p className="text-gray-500">Label</p>  // Too light!
<span className="text-gray-400">Info</span>  // Too light!
<div className="text-gray-500">Empty</div>  // Too light!
```

---

## üìä Backend Query Parameter Handling

### TypeScript-Safe Query Params

```typescript
// ‚úÖ CORRECT: Validate query param types
const { businessId, status } = req.query;

if (!businessId || typeof businessId !== 'string') {
  res.status(400).json({ error: 'Business ID is required' });
  return;
}

const where: Prisma.ModelWhereInput = {
  businessId: businessId  // Now safely typed as string
};

if (status && typeof status === 'string') {
  where.status = status as Prisma.EnumStatusFilter;
}

// ‚ùå WRONG: Direct casting without validation
const businessId = req.query.businessId as string;  // Can fail if array
```

**Rules:**
1. **Check existence**: `if (!param)` before using
2. **Check type**: `typeof param === 'string'` for strings
3. **Handle arrays**: Query params can be `string | string[] | ParsedQs | ParsedQs[]`
4. **No direct casting**: Always validate before casting

---

## üìù TypeScript Type Safety Standards

### Zero `any` Types Policy
```typescript
// ‚ùå NEVER use any
function processData(data: any) { }

// ‚úÖ Use specific types
function processData(data: Record<string, unknown>) { }

// ‚úÖ Use interfaces
interface Business {
  id: string;
  name: string;
  members: BusinessMember[];
}
function processBusiness(data: Business) { }
```

### Express Router Typing
```typescript
// ‚úÖ ALWAYS use explicit router typing
import express from 'express';
const router: express.Router = express.Router();

// ‚ùå NEVER use implicit typing
const router = express.Router(); // TypeScript can't infer properly
```

### Prisma JSON Types
```typescript
// ‚úÖ CORRECT: Use Prisma.InputJsonValue for JSON fields
import { Prisma } from '@prisma/client';

const dashboard = await prisma.dashboard.create({
  data: {
    layout: data.layout as Prisma.InputJsonValue,
    preferences: data.preferences as Prisma.InputJsonValue,
  }
});
```

### Type Guard Pattern
```typescript
// ‚úÖ CORRECT: Use type guards for runtime checks
function hasUserId(user: unknown): user is { id: string } {
  return typeof user === 'object' && user !== null && 'id' in user;
}

if (!hasUserId(req.user)) {
  return res.status(401).json({ error: 'Unauthorized' });
}
// Now TypeScript knows req.user.id exists
```

### Rules
1. **ZERO any types**: Use `unknown`, `Record<string, unknown>`, or specific interfaces
2. **Explicit router types**: Always type Express routers explicitly
3. **Use type guards**: Runtime type checking for dynamic data
4. **Prisma JSON**: Use `Prisma.InputJsonValue` for JSON fields

### When `any` IS Acceptable (With `eslint-disable`)

Only use `any` for genuinely dynamic data with proper documentation:

```typescript
// ‚úÖ ACCEPTABLE: AI/ML runtime data (structure varies by module)
// eslint-disable-next-line @typescript-eslint/no-explicit-any
private async analyzeEventForPatterns(event: any): Promise<Pattern[]> {
  // Event structure is runtime-determined by active modules
}

// ‚úÖ ACCEPTABLE: Dynamic Prisma query builders
// eslint-disable-next-line @typescript-eslint/no-explicit-any
const where: any = { userId };
if (startDate) where.createdAt = { gte: startDate };

// ‚úÖ ACCEPTABLE: WebSocket event handlers (inherently dynamic)
// eslint-disable-next-line @typescript-eslint/no-explicit-any
on(event: string, callback: (...args: any[]) => void): void {
  // Each event type has different data structure
}

// ‚úÖ ACCEPTABLE: Third-party API responses (structure varies by provider)
// eslint-disable-next-line @typescript-eslint/no-explicit-any
async processOAuth2Token(code: string): Promise<{ email: string; attributes: any }> {
  // Different SSO providers return different attributes
}
```

### Decision Tree: Should I Use `any`?

```
Do I know what this type is?
‚îú‚îÄ YES ‚Üí ‚ùå Don't use any! Use specific type, interface, or unknown
‚îî‚îÄ NO ‚Üí Is the structure determined at runtime?
    ‚îú‚îÄ YES ‚Üí Is it genuinely dynamic (AI data, events, third-party APIs)?
    ‚îÇ   ‚îú‚îÄ YES ‚Üí ‚úÖ Use any with eslint-disable comment
    ‚îÇ   ‚îî‚îÄ NO ‚Üí ‚ùå Create a union type or use unknown
    ‚îî‚îÄ NO ‚Üí ‚ùå Don't use any! Type it properly
```

### Examples: Unacceptable vs Acceptable

```typescript
// ‚ùå UNACCEPTABLE: Helper function - type is known
const getOrganizationInfo = (user: any) => { ... }
// FIX: Create interface
interface UserWithBusiness { businesses?: Array<...>; }
const getOrganizationInfo = (user: UserWithBusiness) => { ... }

// ‚ùå UNACCEPTABLE: Array with known type
recentFiles.map((file: any) => ({ id: file.id }))
// FIX: Use proper type
recentFiles.map((file: Record<string, any>) => ({ id: file.id }))

// ‚ùå UNACCEPTABLE: Variable that should infer
let result: any = await prisma.user.findUnique({ ... });
// FIX: Let TypeScript infer
let result = await prisma.user.findUnique({ ... });

// ‚úÖ ACCEPTABLE: AI learning data (truly dynamic)
// eslint-disable-next-line @typescript-eslint/no-explicit-any
private processLearningEvent(event: any): void {
  // Event structure varies by module and runtime configuration
}
```

---

## üóÑÔ∏è Database & Prisma Configuration

### Modular Schema Pattern
```bash
# ‚úÖ CORRECT: Edit module files
prisma/modules/auth/user.prisma
prisma/modules/business/business.prisma
prisma/modules/chat/conversations.prisma

# ‚ùå NEVER: Edit generated schema directly
prisma/schema.prisma  # This is AUTO-GENERATED!
```

### Build Commands (ALWAYS in this order)
```bash
# ‚úÖ CORRECT: Use pnpm prisma commands directly
# 1. Build schema from modules
pnpm prisma:build

# 2. Generate Prisma client
pnpm prisma:generate

# 3. Run migrations (development)
pnpm prisma:migrate

# 4. Apply migrations (production)
pnpm prisma migrate deploy

# OR use combined commands:
pnpm prisma:generate  # Does build + generate
pnpm prisma:migrate   # Does build + migrate

# ‚ùå WRONG: Don't use npm or npx for Prisma commands
npm run prisma:build  # Wrong!
npx prisma generate   # Wrong!
```

**Critical Rule**: ALWAYS use `pnpm prisma` commands. The project uses pnpm as the package manager, and using `npm run` or `npx prisma` may use incorrect versions from global installation instead of the locked version in `pnpm-lock.yaml`.

**‚ö†Ô∏è CRITICAL: Preventing Database Resets**

**The Problem**: Prisma often prompts for database reset when it detects drift (database state doesn't match migration history). This is usually unnecessary and causes data loss.

**The Solution**: 
1. **Always check drift first**: `pnpm prisma migrate status`
2. **Use `--create-only` flag**: Creates migration without applying, letting you review first
3. **Use `prisma migrate resolve`**: Mark migrations as applied if tables already exist
4. **Use `prisma db push` for dev**: Faster sync without migration history (then baseline)

**Why This Happens**:
- Tables created manually or through failed migrations
- Migration history doesn't match actual database state
- Schema changes made without creating migrations first
- Database was modified outside of Prisma migrations

**Prevention**:
- Always create migrations before schema changes are applied
- Never modify database directly (use Prisma migrations only)
- Use `--create-only` to review migrations before applying
- Check `prisma migrate status` regularly to catch drift early

### ‚ö†Ô∏è CRITICAL: Schema Changes REQUIRE Migrations (MANDATORY WORKFLOW)

**NEVER add schema changes without creating a migration. This has caused data loss in the past.**

#### Mandatory Workflow for ANY Schema Change

```bash
# 1. Make schema changes in prisma/modules/[module]/[file].prisma
#    (NEVER edit prisma/schema.prisma directly)

# 2. Rebuild schema from modules
pnpm prisma:build

# 3. CHECK FOR DRIFT FIRST (prevents reset prompts)
pnpm prisma migrate status
# If it says "Database schema is out of sync" or "drift detected":
#   ‚Üí See "Handling Schema Drift" section below

# 4. CREATE MIGRATION (MANDATORY - DO NOT SKIP)
#    Use --create-only to create migration without applying (safer)
pnpm prisma migrate dev --name descriptive_migration_name --create-only

# 5. REVIEW migration SQL to ensure correctness
cat prisma/migrations/[timestamp]_descriptive_migration_name/migration.sql

# 6. APPLY the migration (after review)
pnpm prisma migrate dev

# 7. Generate Prisma client
pnpm prisma:generate

# 8. Test that code works with new schema
```

#### Handling Schema Drift (When Prisma Wants to Reset)

**If `prisma migrate dev` prompts for database reset, DO NOT RESET. Use one of these approaches:**

**Option A: Baseline Migration (Recommended for New Tables)**
```bash
# If tables exist in DB but not in migration history:
# 1. Create migration that matches current DB state
pnpm prisma migrate dev --name baseline_existing_tables --create-only

# 2. Mark it as applied without running SQL (since tables already exist)
pnpm prisma migrate resolve --applied [migration_name]

# 3. Continue with normal workflow
```

**Option B: Use db push for Development (Faster, No Migrations)**
```bash
# For development only - syncs schema to DB without migrations
pnpm prisma db push

# Then create migration from current state
pnpm prisma migrate dev --name sync_existing_state --create-only
pnpm prisma migrate resolve --applied [migration_name]
```

**Option C: Manual Migration Resolution**
```bash
# 1. Check what's different
pnpm prisma migrate diff --from-schema-datasource prisma/schema.prisma --to-schema-datamodel prisma/schema.prisma

# 2. Create migration manually or use --create-only
# 3. If tables already exist, mark migration as applied
pnpm prisma migrate resolve --applied [migration_name]
```

**‚ö†Ô∏è NEVER reset database in development unless:**
- You're starting a fresh project
- You explicitly want to lose all data
- You've backed up all data first

#### What Happens If You Skip Migration Creation

- ‚ùå Code will try to use database columns/tables that don't exist
- ‚ùå Prisma will throw errors: "The column X does not exist"
- ‚ùå Migration drift will be detected
- ‚ùå Database becomes unusable
- ‚ùå **Data loss may occur if database reset is required**

#### Red Flags - STOP If You See These

1. **Schema changes in code but no new migration file**: Migration is missing!
2. **Prisma errors about missing columns/tables**: Schema and database are out of sync
3. **Migration drift warnings from Prisma**: Don't ignore - fix immediately
4. **Code using fields that don't exist in database**: Check if migration was created

#### Example: Adding a New Model

```bash
# ‚úÖ CORRECT workflow:
# 1. Add model to prisma/modules/[module]/[file].prisma
# 2. pnpm prisma:build
# 3. pnpm prisma migrate dev --name add_new_model
# 4. Verify migration file exists
# 5. pnpm prisma:generate
# 6. Test

# ‚ùå WRONG - Missing migration:
# 1. Add model to prisma/modules/[module]/[file].prisma
# 2. pnpm prisma:build
# 3. pnpm prisma:generate
# 4. Start coding... (MIGRATION MISSING - WILL FAIL!)
```

**Remember**: Schema changes are not optional - they MUST have migrations. This is not "nice to have" - it's required for the database to work.

### Database Connection
```typescript
// ‚úÖ CORRECT: Production connection string
DATABASE_URL=postgresql://vssyl_user:ArthurGeorge116!@172.30.0.15:5432/vssyl_production?connection_limit=20&pool_timeout=20

// Connection pool settings (REQUIRED for production)
connection_limit=20    // Max connections
pool_timeout=20        // Connection timeout in seconds
connect_timeout=60     // Initial connection timeout
```

### Prisma Client Configuration
```typescript
// server/src/lib/prisma.ts
const prismaConfig = {
  log: process.env.NODE_ENV === 'development' 
    ? ['query', 'info', 'warn', 'error'] 
    : ['error'],
  datasources: {
    db: {
      url: encodedUrl + '?connection_limit=20&pool_timeout=20&connect_timeout=60'
    }
  }
};

export const prisma = global.prisma || new PrismaClient(prismaConfig);
```

### Rules
1. **NEVER edit `schema.prisma`**: Edit module files in `/prisma/modules/`
2. **ALWAYS run `prisma:build`**: Before generating or migrating
3. **‚ö†Ô∏è CRITICAL: ALWAYS create migration for schema changes**: Adding models, fields, or relations REQUIRES running `pnpm prisma migrate dev --name descriptive_name`. Skipping this causes database errors and potential data loss. See "Schema Changes REQUIRE Migrations" section above.
4. **NEVER edit migration files after they've been applied**: Once a migration is applied to any database (dev, staging, or production), it becomes immutable. Editing migrations causes schema drift and requires database resets.
   - ‚úÖ **CORRECT**: Create a new migration for additional changes
   - ‚ùå **WRONG**: Edit existing migration files in `prisma/migrations/`
   - **Why**: Migrations are historical records. Changing them breaks the migration history and causes drift between environments.
5. **USE connection pooling**: `connection_limit=20&pool_timeout=20` in production
6. **ENCODE passwords**: Use `encodeURIComponent()` for special characters in DB URLs
7. **SINGLETON pattern**: Use global.prisma to prevent multiple instances

---

## ‚òÅÔ∏è Google Cloud Storage Configuration

### Storage Service Pattern
```typescript
// ‚úÖ CORRECT: Use storage service abstraction
import { storageService } from '../services/storageService';

const uploadResult = await storageService.uploadFile(file, destinationPath, {
  makePublic: true,
  metadata: { userId, originalName, folderId }
});

// ‚ùå WRONG: Direct file system access
fs.writeFileSync(path.join(__dirname, 'uploads', filename), buffer);
```

### Provider Configuration
```bash
# Production (Google Cloud Storage)
STORAGE_PROVIDER=gcs
GOOGLE_CLOUD_PROJECT_ID=vssyl-472202
GOOGLE_CLOUD_STORAGE_BUCKET=vssyl-storage-472202
# No GOOGLE_CLOUD_KEY_FILE needed with Application Default Credentials

# Local Development (File System)
STORAGE_PROVIDER=local
LOCAL_UPLOAD_DIR=./uploads
```

### Storage Service Methods
```typescript
// Upload file
await storageService.uploadFile(file, 'path/to/file.jpg', options);

// Delete file
await storageService.deleteFile('path/to/file.jpg');

// Get file URL
const url = storageService.getFileUrl('path/to/file.jpg');

// Check provider
const provider = storageService.getProvider(); // 'gcs' or 'local'
const isGCS = storageService.isGCSConfigured(); // boolean
```

### Rules
1. **ALWAYS use storageService**: Never direct file system access in controllers
2. **CHECK provider**: Use `getProvider()` to handle provider-specific logic
3. **CREATE directories**: Ensure upload directories exist with `recursive: true`
4. **GCS in production**: Always set `STORAGE_PROVIDER=gcs` for production
5. **ADC authentication**: No key file needed when running on Cloud Run

---

## üîÑ Common Error Prevention

### Browser Cache Issues
```typescript
// After deployment, users may see old code due to browser cache
// Solution: Hard refresh instructions
// Ctrl+Shift+R (Windows) or Cmd+Shift+R (Mac)

// For debugging, log environment variables:
console.log('API Config:', {
  NEXT_PUBLIC_API_BASE_URL: process.env.NEXT_PUBLIC_API_BASE_URL,
  NEXT_PUBLIC_API_URL: process.env.NEXT_PUBLIC_API_URL,
  fallback: 'https://vssyl-server-235369681725.us-central1.run.app'
});
```

### WebSocket Authentication
```typescript
// ‚úÖ WebSocket connections REQUIRE authentication
// Expected behavior: Connection fails when user not logged in

if (!token) {
  console.log('WebSocket connection requires authentication');
  return; // Don't attempt to connect
}

// Connect with valid token
socket = io(wsUrl, {
  auth: { token },
  transports: ['websocket']
});
```

### Double API Paths
```typescript
// Problem: Creating /api/chat/api/chat/conversations

// ‚ùå WRONG: apiCall function already adds prefix
const endpoint = '/api/chat/conversations';
return apiCall(endpoint); // Creates /api/chat/api/chat/conversations!

// ‚úÖ CORRECT: Use relative path
const endpoint = '/conversations';
return apiCall(endpoint); // Creates /api/chat/conversations
```

---

## üè¢ Multi-Tenant Data Isolation (CRITICAL SECURITY)

### ALWAYS Scope Database Queries
```typescript
// ‚úÖ CORRECT: Personal context - scope by dashboardId
const files = await prisma.file.findMany({
  where: {
    dashboardId: dashboardId,
    userId: userId,
    trashedAt: null
  }
});

// ‚úÖ CORRECT: Business context - scope by dashboardId AND businessId
const files = await prisma.file.findMany({
  where: {
    dashboardId: dashboardId,
    businessId: businessId,
    trashedAt: null
  }
});

// ‚ùå WRONG: No scoping - data leakage vulnerability!
const files = await prisma.file.findMany({
  where: {
    userId: userId,
    trashedAt: null
  }
});
```

### Data Isolation Rules
1. **Personal context**: MUST include `dashboardId` in all queries
2. **Business context**: MUST include both `dashboardId` AND `businessId`
3. **Household context**: MUST include both `dashboardId` AND `householdId`
4. **NEVER query without context scoping**: Prevents data leakage between tenants
5. **Test isolation**: Verify users cannot access other users' data

### Context Switching Pattern
```typescript
// When user switches contexts, ALL queries must update
const context = {
  dashboardId: currentDashboard.id,
  businessId: currentDashboard.businessId || null,
  householdId: currentDashboard.householdId || null
};

// Pass context to all API calls
const data = await fetchData(context);
```

---

## üõ°Ô∏è Security & Input Validation (MANDATORY)

### Input Validation
```typescript
// ‚úÖ CORRECT: Validate all user input
import { z } from 'zod';

const userSchema = z.object({
  email: z.string().email(),
  password: z.string().min(8),
  name: z.string().min(1).max(100)
});

const validated = userSchema.parse(req.body);

// ‚ùå WRONG: Using user input directly
const user = await prisma.user.create({ data: req.body });
```

### SQL Injection Prevention
```typescript
// ‚úÖ CORRECT: Use Prisma parameterized queries
await prisma.user.findMany({
  where: { email: userEmail }
});

// ‚ùå WRONG: Raw SQL with string interpolation
await prisma.$queryRaw`SELECT * FROM users WHERE email = '${userEmail}'`;
```

### XSS Prevention
```typescript
// ‚úÖ CORRECT: React automatically escapes
<div>{userContent}</div>

// ‚ùå WRONG: Using dangerouslySetInnerHTML without sanitization
<div dangerouslySetInnerHTML={{ __html: userContent }} />

// ‚ö†Ô∏è ACCEPTABLE: Only for trusted content with clear comment
// SECURITY: This is a sanitized theme script, not user content
<script dangerouslySetInnerHTML={{ __html: themeScript }} />
```

### Authentication Validation
```typescript
// ‚úÖ CORRECT: Always validate req.user exists
const user = req.user;
if (!user) {
  return res.status(401).json({ error: 'Authentication required' });
}

// ‚ùå WRONG: Accessing without check
const userId = req.user.id; // Can crash if req.user is undefined
```

### Security Rules
1. **Validate all input**: Use Zod, express-validator, or similar
2. **Use Prisma queries**: Never raw SQL with user input
3. **Escape output**: Let React handle escaping (no dangerouslySetInnerHTML)
4. **Check authentication**: Always verify req.user exists
5. **Sanitize file uploads**: Validate file types and sizes
6. **Rate limit sensitive endpoints**: Login, registration, password reset
7. **Use HTTPS**: All production traffic must be encrypted
8. **Secure headers**: CSP, X-Frame-Options, X-Content-Type-Options

---

## üìä Logging Standards

### Production Logging Pattern
```typescript
// ‚úÖ CORRECT: Use structured logging (IMPLEMENTED & DEPLOYED)
import { logger } from '../lib/logger';

logger.info('User action', { 
  operation: 'file_upload',
  userId, 
  metadata: { fileId, fileName }
});

// ‚úÖ CORRECT: Error logging format
logger.error('Operation failed', { 
  operation: 'database_query',
  error: { 
    message: error.message,
    stack: error.stack 
  },
  context: { userId, operation }
});

// ‚úÖ EXISTING CODE: console.log is acceptable (natural migration strategy)
console.log('Debug info'); // Will be migrated when file is edited

// ‚úÖ NEW CODE: ALWAYS use logger for new code
await logger.info('New feature info', { operation: 'feature_name' });
```

### Error Logging Pattern (TypeScript)

```typescript
// ‚úÖ CORRECT: Type-safe error logging
try {
  // ... operation
} catch (error: unknown) {
  const err = error as Error;
  logger.error('Operation failed', {
    operation: 'operation_name',
    error: { message: err.message, stack: err.stack }
  });
  res.status(500).json({ error: 'Friendly error message' });
}

// ‚ùå WRONG: Non-standard error format (causes TypeScript errors)
catch (error) {
  logger.error('Failed', {
    error: error instanceof Error ? { message: error.message } : { error }
  });
}
```

**Rules:**
1. **Catch as `unknown`**: Always use `catch (error: unknown)`
2. **Cast to Error**: `const err = error as Error;`
3. **Standard format**: `error: { message: err.message, stack: err.stack }`
4. **Include operation**: Always add `operation: 'operation_name'` field

### Logging Utility Structure
```typescript
// server/src/lib/logger.ts (CREATED & DEPLOYED)
export const logger = {
  info: (message: string, meta?: Record<string, unknown>) => {
    if (process.env.NODE_ENV === 'development') {
      console.log(`[INFO] ${message}`, meta);
    }
    // In production: send to logging service (Cloud Logging, Datadog, etc.)
  },
  
  error: (message: string, meta?: Record<string, unknown>) => {
    console.error(`[ERROR] ${message}`, meta);
    // In production: send to error tracking service
  },
  
  warn: (message: string, meta?: Record<string, unknown>) => {
    console.warn(`[WARN] ${message}`, meta);
  },
  
  debug: (message: string, meta?: Record<string, unknown>) => {
    if (process.env.NODE_ENV === 'development') {
      console.debug(`[DEBUG] ${message}`, meta);
    }
  }
};
```

### Logging Rules
1. **Production logging**: Use structured logging with logger utility
2. **Development debugging**: console.log is acceptable for debugging
3. **Error logging**: Always include context (userId, operation, error details)
4. **Never log secrets**: Don't log tokens, passwords, API keys, or sensitive data
5. **Structured data**: Use metadata objects for searchable logs
6. **Log levels**: info (user actions), warn (recoverable issues), error (failures), debug (development only)

### Migration Strategy (PHASE 2 DEFERRED - October 24, 2025)
- **Existing code**: Leave console.log as-is (959 instances) - **NO MIGRATION NEEDED**
- **New code**: **ALWAYS use logger utility** going forward
- **Natural migration**: Convert to logger when editing files for other reasons
- **Rationale**: Logging system fully functional; bulk migration risks outweigh benefits
- **Production**: Logger integrates with Google Cloud Logging (console.log also captured)
- **Decision**: No dedicated migration effort - focus on feature development instead

---

## ü§ñ AI Context System (MANDATORY FOR ALL MODULES)

### Critical Rule: AI Context is Not Optional

**EVERY MODULE MUST IMPLEMENT AI CONTEXT PROVIDERS.**

This is a core platform requirement that makes Vssyl intelligent. Without AI context, the AI assistant cannot answer questions about module data, making it useless to users.

### Why This is Mandatory

- ‚úÖ **Enables Natural Language Queries**: Users can ask "How many employees?" instead of navigating complex UIs
- ‚úÖ **Platform Differentiation**: Most SaaS platforms don't have this level of AI integration
- ‚úÖ **User Experience**: Creates a cohesive, intelligent experience across all modules
- ‚úÖ **Accessibility**: Non-technical users can interact with data using plain English

### Implementation Checklist (Required)

When building ANY new module, you MUST implement AI context:

**1. Planning Phase**:
- [ ] Identify 3-5 key questions users will ask about this module
- [ ] Determine what data the AI needs to answer those questions
- [ ] Design 2-3+ context provider endpoints

**2. Backend Implementation**:
- [ ] Create `[module]AIContextController.ts` with context provider functions
- [ ] Implement each context provider with proper error handling
- [ ] Add routes under `/api/[module]/ai/context/*`
- [ ] Register module in `registerBuiltInModules.ts` with full AI context
- [ ] Test each endpoint with sample businessId

**3. Module Registration**:
```typescript
// server/src/startup/registerBuiltInModules.ts
{
  moduleId: 'your-module',
  moduleName: 'Your Module',
  aiContext: {
    keywords: ['relevant', 'search', 'terms'],
    patterns: [
      'how many items',
      'show me the list',
      'what is the status'
    ],
    entities: ['item', 'category', 'status'],
    actions: ['count items', 'list items', 'check status'],
    contextProviders: [
      {
        name: 'module_overview',
        description: 'General statistics and counts',
        endpoint: '/api/your-module/ai/context/overview'
      },
      {
        name: 'specific_context',
        description: 'Specific data for targeted queries',
        endpoint: '/api/your-module/ai/context/specific'
      }
    ]
  }
}
```

**4. Context Provider Pattern**:
```typescript
/**
 * GET /api/[module]/ai/context/[provider]
 * Returns [specific context] for AI understanding
 */
export async function getContextForAI(req: Request, res: Response) {
  try {
    const userId = (req as any).user?.id || (req as any).user?.sub;
    const { businessId } = req.query;
    
    // 1. Validate authentication
    if (!userId) {
      return res.status(401).json({ 
        success: false, 
        message: 'Authentication required' 
      });
    }

    // 2. Validate businessId (multi-tenant scoping)
    if (!businessId || typeof businessId !== 'string') {
      return res.status(400).json({ 
        success: false, 
        message: 'businessId is required' 
      });
    }

    // 3. Verify access
    const member = await prisma.businessMember.findUnique({
      where: { businessId_userId: { businessId, userId } },
    });

    if (!member || !member.isActive) {
      return res.status(403).json({ 
        success: false, 
        message: 'Access denied' 
      });
    }

    // 4. Query data
    const data = await prisma.yourModel.findMany({
      where: { businessId },
      // ... relevant includes
    });

    // 5. Format for AI (structured with summary)
    const context = {
      summary: {
        totalCount: data.length,
        status: data.length > 0 ? 'has-data' : 'empty'
      },
      details: data.map(item => ({
        // Relevant fields only
      }))
    };

    // 6. Return standardized response
    res.json({
      success: true,
      context,
      metadata: {
        provider: 'your-module',
        endpoint: 'overview',
        businessId,
        timestamp: new Date().toISOString()
      }
    });
    
  } catch (error) {
    console.error('Error in getContextForAI:', error);
    res.status(500).json({ 
      success: false, 
      message: 'Failed to fetch context',
      error: error instanceof Error ? error.message : 'Unknown error'
    });
  }
}
```

### Response Format (Standardized)

All AI context providers MUST return this format:

```typescript
{
  success: true,
  context: {
    summary: {
      // High-level metrics AI can use for quick answers
      totalCount: 45,
      status: 'good' | 'warning' | 'critical',
      requiresAction: boolean
    },
    details: {
      // Specific data points
      items: [...],
      breakdown: {...}
    }
  },
  metadata: {
    provider: 'module-name',
    endpoint: 'context-provider-name',
    businessId: 'xxx',
    timestamp: '2025-11-13T...'
  }
}
```

### Current Implementation Status

**‚úÖ Implemented** (5 modules):
- **Drive**: `recent_files`, `storage_stats`, `file_search`
- **Chat**: `recent_conversations`, `unread_messages`, `conversation_history`
- **Calendar**: `upcoming_events`, `today_schedule`, `availability`
- **HR**: `hr_overview`, `employee_count`, `time_off_summary`
- **Scheduling**: `scheduling_overview`, `coverage_status`, `scheduling_conflicts`

**üöß Required for Future Modules**:
- All new modules MUST implement AI context from day one
- No exceptions - this is a core platform requirement

### Don't Skip This!

Common mistakes:
- ‚ùå "We'll add AI context later" ‚Üí NO! Implement it NOW
- ‚ùå "This module is too simple for AI" ‚Üí Every module needs it
- ‚ùå "Just return raw database records" ‚Üí Format for AI consumption
- ‚ùå "Generic getAll endpoint is fine" ‚Üí Create specific context providers

For complete documentation, see: `memory-bank/aiContextSystem.md`

---

## üîî Notification Integration Standards (MANDATORY FOR ALL MODULES)

### Critical Rule: Notifications Are Not Optional

**Every module MUST integrate with the global notification system.** Notifications enable:
- Real-time user awareness of important events
- Centralized notification management (`/notifications`)
- Email and push notification support
- Better user engagement and retention

### Notification Type Naming Convention

**CRITICAL**: Follow the pattern `[module]_[event]` for all notification types:

```typescript
// ‚úÖ CORRECT: Module prefix + underscore + event name
'hr_onboarding_task_approved'
'hr_time_off_request_submitted'
'chat_message'
'drive_file_shared'
'calendar_event_reminder'

// ‚ùå WRONG: Generic or inconsistent naming
'onboarding_approved'  // Missing module prefix
'taskApproved'         // Wrong format (camelCase)
'hr-task-approved'     // Wrong separator (hyphen)
'system_notification' // Too generic
```

### Backend Implementation Pattern

```typescript
// ‚úÖ CORRECT: Use NotificationService in service/controller
import { NotificationService } from '../services/notificationService';
import { logger } from '../lib/logger';

export async function yourServiceFunction(input: YourInput) {
  // ... your business logic ...
  
  // Send notification (don't fail operation if notification fails)
  try {
    await NotificationService.createNotification({
      userId: targetUserId,  // Who receives the notification
      type: 'your_module_event_name',  // Follow naming convention
      title: 'Clear, Descriptive Title',
      body: `Contextual message: "${relevantData}"`,
      data: {
        // Include IDs for navigation
        itemId: item.id,
        businessId: businessId,
        // Optional: Add action URLs
        actionUrl: `/business/${businessId}/workspace/your-module`
      }
    });
  } catch (notificationError) {
    // Don't fail the operation if notification fails
    await logger.warn('Failed to send notification', {
      operation: 'notification_error',
      error: notificationError instanceof Error ? notificationError.message : 'Unknown error'
    });
  }
  
  return result;
}
```

### Frontend Integration Requirements

**MANDATORY**: When adding new notification types, update these files:

1. **`web/src/app/notifications/page.tsx`**:
   - Add types to `getNormalizedType()` function
   - Add category icon to `getNotificationIcon()` if new category
   - Add category to `categories` array if new category

2. **`web/src/api/notifications.ts`**:
   - Add category to `Notification` interface `type` union

### Notification Categories

Current categories (add new ones as needed):
- **chat**: Chat messages, reactions (`chat_message`, `chat_reaction`)
- **drive**: File sharing, permissions (`drive_shared`, `drive_permission`)
- **members**: Member requests, invitations (`member_request`, `business_invitation`)
- **business**: Business updates (`business_invitation`)
- **hr**: HR module notifications (`hr_onboarding_*`, `hr_time_off_*`, `hr_attendance_*`)
- **mentions**: @mentions in chat (`chat_mention`)
- **system**: System alerts, maintenance (`system_alert`)

### Rules

1. **ALWAYS use NotificationService**: Never create notifications directly in database
2. **ALWAYS define notification metadata**: Add `notifications` array to module manifest (REQUIRED)
3. **ALWAYS handle errors gracefully**: Wrap in try-catch, don't fail operations
4. **ALWAYS follow naming convention**: `[module]_[event]` format
5. **ALWAYS include metadata**: Add IDs and URLs in `data` field for navigation
6. **NEVER use generic types**: Use module-specific types, not just 'system'
7. **NEVER fail operations**: Notification failures shouldn't break functionality

**CRITICAL**: Notification metadata in module manifest is now REQUIRED. The notification center and settings page automatically discover notification types from module manifests. Without metadata, notifications won't appear properly categorized.

### Common Notification Events by Module

**HR Module**:
- `hr_onboarding_task_approved` - Task approved by manager
- `hr_onboarding_task_pending_approval` - Task needs approval
- `hr_onboarding_journey_completed` - All tasks completed
- `hr_time_off_request_submitted` - Request submitted (notify manager)
- `hr_time_off_request_approved` - Request approved (notify employee)
- `hr_time_off_request_denied` - Request denied (notify employee)
- `hr_time_off_balance_low` - Balance below threshold
- `hr_attendance_exception_created` - Exception detected
- `hr_attendance_policy_violation` - Policy violation
- `hr_attendance_missing_punch` - Missing punch reminder

**Chat Module**:
- `chat_message` - New message in conversation
- `chat_mention` - User mentioned in message
- `chat_reaction` - Reaction to message

**Drive Module**:
- `drive_shared` - File shared with user
- `drive_permission` - Permission changed

### Testing Checklist

- [ ] Notification appears in notification center (`/notifications`)
- [ ] Notification appears in correct category
- [ ] Notification badge count increments
- [ ] Real-time WebSocket update works
- [ ] Notification includes correct metadata
- [ ] Clicking notification navigates correctly
- [ ] Mark as read works
- [ ] Email notification sent (if configured)
- [ ] Push notification sent (if configured)

For complete documentation, see: `.cursor/rules/module-development.mdc` (Notification Integration Standards section)

---

## üìã Development Workflow

### Starting Development
```bash
# From project root (starts both frontend and backend)
pnpm dev

# Frontend runs on: http://localhost:3000
# Backend runs on:  http://localhost:5000
```

### Before Committing
```bash
# 1. Run linter
pnpm lint

# 2. Check TypeScript
pnpm type-check

# 3. Build Prisma schema (if database changes)
pnpm prisma:build

# 4. Generate Prisma client (if schema changed)
pnpm prisma:generate
```

### Deployment Checklist
- [ ] All environment variables set in production
- [ ] No localhost URLs in code
- [ ] Database migrations run successfully
- [ ] Storage provider set to `gcs`
- [ ] Build completes in <15 minutes
- [ ] All API routes return correct status codes (not 404)
- [ ] WebSocket connections work when authenticated

---

## üö® Critical "DO NOT" Rules

### ‚ùå NEVER Do These:
1. **Hardcode localhost** in production code
2. **Edit `prisma/schema.prisma`** directly (edit modules instead)
3. **Edit migration files after they've been applied** - Once a migration is applied to any database, it becomes immutable. Editing causes schema drift and requires database resets. Create a new migration instead.
4. **Use `any` types** (use proper TypeScript types)
5. **Use light text colors on light backgrounds** - NEVER use `text-gray-500`, `text-gray-400`, or `text-gray-300` on white/light backgrounds. Use `text-gray-700` or darker. This causes severe readability issues.
6. **Create double `/api` paths** (use relative paths in API clients)
7. **Bypass Next.js API proxy** (always use `/api/*` routes)
8. **Skip connection pooling** in production Prisma config
9. **Use direct file system** access (use storageService)
10. **Forget fallback URLs** in environment variable logic
11. **Log sensitive data** (tokens, passwords, secrets)
12. **Skip environment variable validation** at startup
13. **Import from non-existent `apiClient`** (use native fetch with authHeaders)
14. **Use wrong component import paths** (use `shared/components` not `@/components/ui`)
15. **Use non-existent Button variants** (`primary`|`secondary`|`ghost` only)
16. **Use Card subcomponents** (no CardHeader, CardTitle, CardContent)
17. **Cast query params without validation** (always check `typeof param === 'string'`)
18. **Mismatch controller/route names** (must match exactly)
19. **Forget `.js` extension** on controller imports
20. **Skip AI context implementation** (EVERY module MUST have AI context providers)

---

## ‚úÖ Always Do These:

### Every New Feature
1. **Read memory bank** files first
2. **Follow TypeScript** standards (zero `any` types)
3. **Use environment variables** with fallbacks
4. **Ensure text readability** - Use `text-gray-700` or darker on light backgrounds
5. **Test both** local and production configurations
6. **Update documentation** in memory bank
7. **Run linter** before committing
8. **Check build** completes successfully
9. **Verify API routes** return correct status codes

### Every API Endpoint
1. **Validate authentication** (check `req.user` exists)
2. **Use environment variables** (no hardcoded URLs)
3. **Return consistent** error responses
4. **Log errors** with context
5. **Handle edge cases** (missing data, invalid tokens)

### Every Database Query
1. **Use Prisma** (no raw SQL unless necessary)
2. **Check connection** pooling settings
3. **Handle errors** gracefully
4. **Use transactions** for related operations
5. **Encode special characters** in connection strings

### Every Module (MANDATORY)
1. **Implement AI context** from day one (2-3+ context providers)
2. **Register in `registerBuiltInModules.ts`** with full AI context definition
3. **Create dedicated `*AIContextController.ts`** file
4. **Add routes** under `/api/[module]/ai/context/*`
5. **Test context endpoints** with real businessId
6. **Document** what questions the AI can answer
7. **Follow standardized response format** (success, context, metadata)
8. **Integrate notifications** using `NotificationService.createNotification()`
9. **Follow naming convention** `[module]_[event]` for notification types
10. **Update frontend** notification categorization in notification page
11. **Handle errors gracefully** - don't fail operations if notifications fail

---

## üéØ Quick Reference

### When You See This Error...

**"404 Not Found" on API routes:**
- Check environment variables are set
- Verify fallback URLs are correct
- Ensure no double `/api` paths

**"Database connection failed":**
- Check `DATABASE_URL` format
- Verify connection pooling settings
- Ensure IP address is correct (172.30.0.15)

**"WebSocket connection failed":**
- Check user is authenticated
- Verify `NEXT_PUBLIC_WS_URL` is set
- This is EXPECTED when not logged in

**"Type 'any' is not allowed":**
- Replace with specific interface
- Use `Record<string, unknown>` for flexible objects
- Use type guards for runtime checking

**"Cannot find module 'prisma/schema.prisma'":**
- Run `npm run prisma:build` first
- Then run `npm run prisma:generate`
- Check `/prisma/schema.prisma` exists

---

## üìö Additional Resources

- **Memory Bank**: `/memory-bank/` (comprehensive documentation)
- **AI Coding Standards**: `/memory-bank/AI_CODING_STANDARDS.md`
- **System Patterns**: `/memory-bank/systemPatterns.md`
- **Troubleshooting**: `/memory-bank/troubleshooting.md`
- **Tech Context**: `/memory-bank/techContext.md`
- **Database Context**: `/memory-bank/databaseContext.md`

---

**Last Updated**: 2025-10-16  
**Status**: ‚úÖ Production-Ready Patterns  
**Maintainer**: Development Team
